{"ast":null,"code":"'use strict';\n\nrequire('abort-controller/polyfill');\n\nvar util = require('../_util');\n\nvar faunaErrors = require('../errors');\n\nvar errors = require('./errors');\n/**\n * Http client adapter built around fetch API.\n *\n * @constructor\n * @param {?object} options FetchAdapter options.\n * @param {?boolean} options.keepAlive Whether use keep-alive connection.\n * @param {?boolean} options.isHttps Whether use https connection.\n * @param {?function} options.fetch Fetch compatible API.\n * @private\n */\n\n\nfunction FetchAdapter(options) {\n  options = options || {};\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n\n  this.type = 'fetch';\n  this._fetch = resolveFetch(options.fetch);\n\n  if (util.isNodeEnv() && options.keepAlive) {\n    this._keepAliveEnabledAgent = new (options.isHttps ? require('https') : require('http')).Agent({\n      keepAlive: true\n    });\n  }\n}\n/**\n * Issues http requests using fetch API.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\n\n\nFetchAdapter.prototype.execute = function (options) {\n  var signal = options.signal; // Use timeout only if no signal provided\n\n  var useTimeout = !options.signal && !!options.timeout;\n  var timerId;\n\n  var cleanup = function () {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n  };\n\n  var onResponse = function (response) {\n    cleanup();\n    var headers = responseHeadersAsObject(response.headers);\n    var isStreaming = response.ok && options.streamConsumer != null; // Regular request - return text content immediately.\n\n    if (!isStreaming) {\n      return response.text().then(function (content) {\n        return {\n          body: content,\n          headers: headers,\n          status: response.status\n        };\n      });\n    }\n\n    attachStreamConsumer(response, options.streamConsumer);\n    return {\n      // Syntactic stream representation.\n      body: '[stream]',\n      headers: headers,\n      status: response.status\n    };\n  };\n\n  var onError = function (error) {\n    cleanup();\n    return Promise.reject(remapFetchError(error, useTimeout));\n  };\n\n  if (useTimeout) {\n    var ctrl = new AbortController();\n    signal = ctrl.signal;\n    timerId = setTimeout(ctrl.abort.bind(ctrl), options.timeout);\n  }\n\n  return this._fetch(util.formatUrl(options.origin, options.path, options.query), {\n    method: options.method,\n    headers: options.headers,\n    body: options.body,\n    agent: this._keepAliveEnabledAgent,\n    signal: signal\n  }).then(onResponse).catch(onError);\n};\n/**\n * Attaches streamConsumer specifically either for browser or NodeJS.\n * Minimum browser compatibility based on current code:\n * Chrome                52\n * Edge                  79\n * Firefox               65\n * IE                    NA\n * Opera                 39\n * Safari                10.1\n * Android Webview       52\n * Chrome for Android    52\n * Firefox for Android   65\n * Opera for Android     41\n * Safari on iOS         10.3\n * Samsung Internet      6.0\n *\n * @param response Fetch response.\n * @param consumer StreamConsumer.\n * @private\n */\n\n\nfunction attachStreamConsumer(response, consumer) {\n  var onError = function (error) {\n    consumer.onError(remapFetchError(error));\n  };\n\n  if (util.isNodeEnv()) {\n    response.body.on('error', onError).on('data', consumer.onData).on('end', function () {\n      // To simulate how browsers behave in case of \"end\" event.\n      consumer.onError(new TypeError('network error'));\n    });\n    return;\n  } // ATTENTION: The following code is meant to run in browsers and is not\n  // covered by current test automation. Manual testing on major browsers\n  // is required after making changes to it.\n\n\n  try {\n    var reader = response.body.getReader();\n    var decoder = new TextDecoder('utf-8');\n\n    function pump() {\n      return reader.read().then(function (msg) {\n        if (!msg.done) {\n          var chunk = decoder.decode(msg.value, {\n            stream: true\n          });\n          consumer.onData(chunk);\n          return pump();\n        } // In case a browser hasn't thrown the \"network error\" on stream's end\n        // we need to force it in order to provide a way to handle stream's\n        // ending.\n\n\n        consumer.onError(new TypeError('network error'));\n      });\n    }\n\n    pump().catch(onError);\n  } catch (err) {\n    throw new faunaErrors.StreamsNotSupported('Please, consider providing a Fetch API-compatible function ' + 'with streamable response bodies. ' + err);\n  }\n}\n/**\n * Remaps fetch error to HttpClient's one for timeout and abort use-cases.\n * Thus HttpClient will expose the same errors.\n *\n * @param {object} error Error object.\n * @param {?boolean} useTimeout Whether timeout is specified.\n * @returns {object} Remapped or original error.\n * @private\n */\n\n\nfunction remapFetchError(error, useTimeout) {\n  var isAbortError = error && error.name === 'AbortError';\n\n  if (!isAbortError) {\n    return error;\n  }\n\n  return useTimeout ? new errors.TimeoutError() : new errors.AbortError();\n}\n/**\n * Resolves which Fetch API compatible function to use. If an override is\n * provided, returns the override. If no override and the global (window) has\n * \"fetch\" property, return the native fetch. Otherwise returns the cross-fetch polyfill.\n *\n * @param {?function} fetchOverride An Fetch API compatible function to use.\n * @returns {function} A Fetch API compatible function.\n * @private\n */\n\n\nfunction resolveFetch(fetchOverride) {\n  if (typeof fetchOverride === 'function') {\n    return fetchOverride;\n  }\n\n  if (typeof global.fetch === 'function') {\n    // NB. Rebinding to global is needed for Safari\n    return global.fetch.bind(global);\n  }\n\n  return require('cross-fetch');\n}\n/**\n * Converts fetch Headers object into POJO.\n *\n * @param {object} headers Fetch Headers object.\n * @returns {object} Response headers as a plain object.\n * @private\n */\n\n\nfunction responseHeadersAsObject(headers) {\n  var result = {};\n\n  for (var header of headers.entries()) {\n    var key = header[0];\n    var value = header[1];\n    result[key] = value;\n  }\n\n  return result;\n}\n\nmodule.exports = FetchAdapter;","map":{"version":3,"sources":["/Users/matt/Documents/Programming/Projects/barcode-generator/node_modules/faunadb/src/_http/fetchAdapter.js"],"names":["require","util","faunaErrors","errors","FetchAdapter","options","type","_fetch","resolveFetch","fetch","isNodeEnv","keepAlive","_keepAliveEnabledAgent","isHttps","Agent","prototype","execute","signal","useTimeout","timeout","timerId","cleanup","clearTimeout","onResponse","response","headers","responseHeadersAsObject","isStreaming","ok","streamConsumer","text","then","content","body","status","attachStreamConsumer","onError","error","Promise","reject","remapFetchError","ctrl","AbortController","setTimeout","abort","bind","formatUrl","origin","path","query","method","agent","catch","consumer","on","onData","TypeError","reader","getReader","decoder","TextDecoder","pump","read","msg","done","chunk","decode","value","stream","err","StreamsNotSupported","isAbortError","name","TimeoutError","AbortError","fetchOverride","global","result","header","entries","key","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nrequire('abort-controller/polyfill')\nvar util = require('../_util')\nvar faunaErrors = require('../errors')\nvar errors = require('./errors')\n\n/**\n * Http client adapter built around fetch API.\n *\n * @constructor\n * @param {?object} options FetchAdapter options.\n * @param {?boolean} options.keepAlive Whether use keep-alive connection.\n * @param {?boolean} options.isHttps Whether use https connection.\n * @param {?function} options.fetch Fetch compatible API.\n * @private\n */\nfunction FetchAdapter(options) {\n  options = options || {}\n\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n  this.type = 'fetch'\n  this._fetch = resolveFetch(options.fetch)\n\n  if (util.isNodeEnv() && options.keepAlive) {\n    this._keepAliveEnabledAgent = new (options.isHttps\n      ? require('https')\n      : require('http')\n    ).Agent({ keepAlive: true })\n  }\n}\n\n/**\n * Issues http requests using fetch API.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\nFetchAdapter.prototype.execute = function(options) {\n  var signal = options.signal\n  // Use timeout only if no signal provided\n  var useTimeout = !options.signal && !!options.timeout\n  var timerId\n\n  var cleanup = function() {\n    if (timerId) {\n      clearTimeout(timerId)\n    }\n  }\n\n  var onResponse = function(response) {\n    cleanup()\n\n    var headers = responseHeadersAsObject(response.headers)\n    var isStreaming = response.ok && options.streamConsumer != null\n\n    // Regular request - return text content immediately.\n    if (!isStreaming) {\n      return response.text().then(function(content) {\n        return {\n          body: content,\n          headers: headers,\n          status: response.status,\n        }\n      })\n    }\n\n    attachStreamConsumer(response, options.streamConsumer)\n\n    return {\n      // Syntactic stream representation.\n      body: '[stream]',\n      headers: headers,\n      status: response.status,\n    }\n  }\n\n  var onError = function(error) {\n    cleanup()\n\n    return Promise.reject(remapFetchError(error, useTimeout))\n  }\n\n  if (useTimeout) {\n    var ctrl = new AbortController()\n\n    signal = ctrl.signal\n    timerId = setTimeout(ctrl.abort.bind(ctrl), options.timeout)\n  }\n\n  return this._fetch(\n    util.formatUrl(options.origin, options.path, options.query),\n    {\n      method: options.method,\n      headers: options.headers,\n      body: options.body,\n      agent: this._keepAliveEnabledAgent,\n      signal: signal,\n    }\n  )\n    .then(onResponse)\n    .catch(onError)\n}\n\n/**\n * Attaches streamConsumer specifically either for browser or NodeJS.\n * Minimum browser compatibility based on current code:\n * Chrome                52\n * Edge                  79\n * Firefox               65\n * IE                    NA\n * Opera                 39\n * Safari                10.1\n * Android Webview       52\n * Chrome for Android    52\n * Firefox for Android   65\n * Opera for Android     41\n * Safari on iOS         10.3\n * Samsung Internet      6.0\n *\n * @param response Fetch response.\n * @param consumer StreamConsumer.\n * @private\n */\nfunction attachStreamConsumer(response, consumer) {\n  var onError = function(error) {\n    consumer.onError(remapFetchError(error))\n  }\n\n  if (util.isNodeEnv()) {\n    response.body\n      .on('error', onError)\n      .on('data', consumer.onData)\n      .on('end', function() {\n        // To simulate how browsers behave in case of \"end\" event.\n        consumer.onError(new TypeError('network error'))\n      })\n\n    return\n  }\n\n  // ATTENTION: The following code is meant to run in browsers and is not\n  // covered by current test automation. Manual testing on major browsers\n  // is required after making changes to it.\n  try {\n    var reader = response.body.getReader()\n    var decoder = new TextDecoder('utf-8')\n\n    function pump() {\n      return reader.read().then(function(msg) {\n        if (!msg.done) {\n          var chunk = decoder.decode(msg.value, { stream: true })\n\n          consumer.onData(chunk)\n\n          return pump()\n        }\n\n        // In case a browser hasn't thrown the \"network error\" on stream's end\n        // we need to force it in order to provide a way to handle stream's\n        // ending.\n        consumer.onError(new TypeError('network error'))\n      })\n    }\n\n    pump().catch(onError)\n  } catch (err) {\n    throw new faunaErrors.StreamsNotSupported(\n      'Please, consider providing a Fetch API-compatible function ' +\n        'with streamable response bodies. ' +\n        err\n    )\n  }\n}\n\n/**\n * Remaps fetch error to HttpClient's one for timeout and abort use-cases.\n * Thus HttpClient will expose the same errors.\n *\n * @param {object} error Error object.\n * @param {?boolean} useTimeout Whether timeout is specified.\n * @returns {object} Remapped or original error.\n * @private\n */\nfunction remapFetchError(error, useTimeout) {\n  var isAbortError = error && error.name === 'AbortError'\n\n  if (!isAbortError) {\n    return error\n  }\n\n  return useTimeout ? new errors.TimeoutError() : new errors.AbortError()\n}\n\n/**\n * Resolves which Fetch API compatible function to use. If an override is\n * provided, returns the override. If no override and the global (window) has\n * \"fetch\" property, return the native fetch. Otherwise returns the cross-fetch polyfill.\n *\n * @param {?function} fetchOverride An Fetch API compatible function to use.\n * @returns {function} A Fetch API compatible function.\n * @private\n */\nfunction resolveFetch(fetchOverride) {\n  if (typeof fetchOverride === 'function') {\n    return fetchOverride\n  }\n\n  if (typeof global.fetch === 'function') {\n    // NB. Rebinding to global is needed for Safari\n    return global.fetch.bind(global)\n  }\n\n  return require('cross-fetch')\n}\n\n/**\n * Converts fetch Headers object into POJO.\n *\n * @param {object} headers Fetch Headers object.\n * @returns {object} Response headers as a plain object.\n * @private\n */\nfunction responseHeadersAsObject(headers) {\n  var result = {}\n\n  for (var header of headers.entries()) {\n    var key = header[0]\n    var value = header[1]\n\n    result[key] = value\n  }\n\n  return result\n}\n\nmodule.exports = FetchAdapter\n"]},"metadata":{},"sourceType":"script"}