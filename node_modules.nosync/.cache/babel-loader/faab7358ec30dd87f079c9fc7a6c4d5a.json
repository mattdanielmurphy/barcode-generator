{"ast":null,"code":"'use strict';\n\nvar http2 = require('http2');\n\nvar errors = require('./errors');\n\nvar util = require('../_util');\n\nvar STREAM_PREFIX = 'stream::';\n/**\n * Http client adapter built around NodeJS http2 module.\n *\n * @constructor\n * @param {object} options Http2Adapter options.\n * @param {number} options.http2SessionIdleTime The time (in milliseconds) that\n * an HTTP2 session may live when there's no activity.\n * @private\n */\n\nfunction Http2Adapter(options) {\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n  this.type = 'http2';\n  /**\n   * Serves for reusing http2 sessions between multiple calls.\n   *\n   * @type {object}\n   * @private\n   */\n\n  this._sessionMap = {};\n  /**\n   * The time (in ms) that an HTTP2 session may live when there's no activity.\n   *\n   * @type {number}\n   * @private\n   */\n\n  this._http2SessionIdleTime = options.http2SessionIdleTime;\n}\n/**\n * Resolves ClientHttp2Session to be reused across multiple requests.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request. A separate session\n * is created for streaming requests to avoid shared resources with regular\n * ones for the purpose of reliability.\n * @returns {object} An interface to operate with HTTP2 session.\n */\n\n\nHttp2Adapter.prototype._resolveSessionFor = function (origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin;\n\n  if (this._sessionMap[sessionKey]) {\n    return this._sessionMap[sessionKey];\n  }\n\n  var self = this;\n  var timerId = null;\n  var ongoingRequests = 0;\n\n  var cleanup = function () {\n    self._cleanupSessionFor(origin, isStreaming);\n  };\n\n  var clearInactivityTimeout = function () {\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n  };\n\n  var setInactivityTimeout = function () {\n    clearInactivityTimeout();\n\n    var onTimeout = function () {\n      timerId = null;\n\n      if (ongoingRequests === 0) {\n        cleanup();\n      }\n    };\n\n    timerId = setTimeout(onTimeout, self._http2SessionIdleTime);\n  };\n\n  var sessionInterface = {\n    session: http2.connect(origin).once('error', cleanup).once('goaway', cleanup),\n    onRequestStart: function onRequestStart() {\n      ++ongoingRequests;\n      clearInactivityTimeout();\n    },\n    onRequestEnd: function onRequestEnd() {\n      --ongoingRequests; // Set inactivity timer only if there are no ongoing requests.\n\n      if (ongoingRequests === 0) {\n        setInactivityTimeout();\n      }\n    }\n  };\n  this._sessionMap[sessionKey] = sessionInterface;\n  return sessionInterface;\n};\n/**\n * Performs cleanup for broken session.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request.\n * @returns {void}\n */\n\n\nHttp2Adapter.prototype._cleanupSessionFor = function (origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin;\n\n  if (this._sessionMap[sessionKey]) {\n    this._sessionMap[sessionKey].session.close();\n\n    delete this._sessionMap[sessionKey];\n  }\n};\n/**\n * Issues http requests using http2 module.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\n\n\nHttp2Adapter.prototype.execute = function (options) {\n  var self = this;\n  var isStreaming = options.streamConsumer != null;\n  return new Promise(function (resolvePromise, rejectPromise) {\n    var isPromiseSettled = false;\n    var isCanceled = false;\n\n    var resolve = function (value) {\n      isPromiseSettled = true;\n      resolvePromise(value);\n    }; // If an error has occurred after the Promise is settled\n    // we need to call streamConsumer.onError instead of reject function.\n    // Possible scenario is aborting request when stream is already being consumed.\n\n\n    var rejectOrOnError = function (error) {\n      if (isPromiseSettled && isStreaming) {\n        return options.streamConsumer.onError(error);\n      }\n\n      isPromiseSettled = true;\n      rejectPromise(error);\n    };\n\n    var onSettled = function () {\n      sessionInterface.onRequestEnd();\n\n      if (options.signal) {\n        options.signal.removeEventListener('abort', onAbort);\n      }\n    };\n\n    var onError = function (error) {\n      onSettled();\n      rejectOrOnError(error);\n    };\n\n    var onAbort = function () {\n      isCanceled = true;\n      onSettled();\n      request.close(http2.constants.NGHTTP2_CANCEL);\n      rejectOrOnError(new errors.AbortError());\n    };\n\n    var onTimeout = function () {\n      isCanceled = true;\n      onSettled();\n      request.close(http2.constants.NGHTTP2_CANCEL);\n      rejectOrOnError(new errors.TimeoutError());\n    };\n\n    var onResponse = function (responseHeaders) {\n      var status = responseHeaders[http2.constants.HTTP2_HEADER_STATUS];\n      var isOkStatus = status >= 200 && status < 400;\n      var processStream = isOkStatus && isStreaming;\n      var responseBody = '';\n\n      var onData = function (chunk) {\n        if (processStream) {\n          return options.streamConsumer.onData(chunk);\n        }\n\n        responseBody += chunk;\n      };\n\n      var onEnd = function () {\n        if (!isCanceled) {\n          onSettled();\n        }\n\n        if (!processStream) {\n          return resolve({\n            body: responseBody,\n            headers: responseHeaders,\n            status: status\n          });\n        } // Call .onError with TypeError only if the request hasn't been canceled\n        // in order to align on how FetchAdapter works - it throws the TypeError\n        // due to underlying fetch API mechanics.\n\n\n        if (!isCanceled) {\n          options.streamConsumer.onError(new TypeError('network error'));\n        }\n      };\n\n      if (processStream) {\n        resolve({\n          // Syntactic stream representation.\n          body: '[stream]',\n          headers: responseHeaders,\n          status: status\n        });\n      }\n\n      request.on('data', onData).on('end', onEnd);\n    };\n\n    try {\n      var pathname = (options.path[0] === '/' ? options.path : '/' + options.path) + util.querystringify(options.query, '?');\n      var requestHeaders = Object.assign({}, options.headers, {\n        [http2.constants.HTTP2_HEADER_PATH]: pathname,\n        [http2.constants.HTTP2_HEADER_METHOD]: options.method\n      });\n\n      var sessionInterface = self._resolveSessionFor(options.origin, isStreaming);\n\n      var request = sessionInterface.session.request(requestHeaders).setEncoding('utf8').on('error', onError).on('response', onResponse);\n      sessionInterface.onRequestStart(); // Set up timeout only if no signal provided.\n\n      if (!options.signal && options.timeout) {\n        request.setTimeout(options.timeout, onTimeout);\n      }\n\n      if (options.signal) {\n        options.signal.addEventListener('abort', onAbort);\n      }\n\n      if (options.body != null) {\n        request.write(options.body);\n      }\n\n      request.end();\n    } catch (error) {\n      self._cleanupSessionFor(options.origin, isStreaming);\n\n      rejectOrOnError(error);\n    }\n  });\n};\n\nmodule.exports = Http2Adapter;","map":{"version":3,"sources":["/Users/matt/Documents/Programming/Projects/barcode-generator/node_modules/faunadb/src/_http/http2Adapter.js"],"names":["http2","require","errors","util","STREAM_PREFIX","Http2Adapter","options","type","_sessionMap","_http2SessionIdleTime","http2SessionIdleTime","prototype","_resolveSessionFor","origin","isStreaming","sessionKey","self","timerId","ongoingRequests","cleanup","_cleanupSessionFor","clearInactivityTimeout","clearTimeout","setInactivityTimeout","onTimeout","setTimeout","sessionInterface","session","connect","once","onRequestStart","onRequestEnd","close","execute","streamConsumer","Promise","resolvePromise","rejectPromise","isPromiseSettled","isCanceled","resolve","value","rejectOrOnError","error","onError","onSettled","signal","removeEventListener","onAbort","request","constants","NGHTTP2_CANCEL","AbortError","TimeoutError","onResponse","responseHeaders","status","HTTP2_HEADER_STATUS","isOkStatus","processStream","responseBody","onData","chunk","onEnd","body","headers","TypeError","on","pathname","path","querystringify","query","requestHeaders","Object","assign","HTTP2_HEADER_PATH","HTTP2_HEADER_METHOD","method","setEncoding","timeout","addEventListener","write","end","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nvar http2 = require('http2')\nvar errors = require('./errors')\nvar util = require('../_util')\n\nvar STREAM_PREFIX = 'stream::'\n\n/**\n * Http client adapter built around NodeJS http2 module.\n *\n * @constructor\n * @param {object} options Http2Adapter options.\n * @param {number} options.http2SessionIdleTime The time (in milliseconds) that\n * an HTTP2 session may live when there's no activity.\n * @private\n */\nfunction Http2Adapter(options) {\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n  this.type = 'http2'\n  /**\n   * Serves for reusing http2 sessions between multiple calls.\n   *\n   * @type {object}\n   * @private\n   */\n  this._sessionMap = {}\n  /**\n   * The time (in ms) that an HTTP2 session may live when there's no activity.\n   *\n   * @type {number}\n   * @private\n   */\n  this._http2SessionIdleTime = options.http2SessionIdleTime\n}\n\n/**\n * Resolves ClientHttp2Session to be reused across multiple requests.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request. A separate session\n * is created for streaming requests to avoid shared resources with regular\n * ones for the purpose of reliability.\n * @returns {object} An interface to operate with HTTP2 session.\n */\nHttp2Adapter.prototype._resolveSessionFor = function(origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin\n\n  if (this._sessionMap[sessionKey]) {\n    return this._sessionMap[sessionKey]\n  }\n\n  var self = this\n  var timerId = null\n  var ongoingRequests = 0\n\n  var cleanup = function() {\n    self._cleanupSessionFor(origin, isStreaming)\n  }\n\n  var clearInactivityTimeout = function() {\n    if (timerId) {\n      clearTimeout(timerId)\n      timerId = null\n    }\n  }\n\n  var setInactivityTimeout = function() {\n    clearInactivityTimeout()\n\n    var onTimeout = function() {\n      timerId = null\n\n      if (ongoingRequests === 0) {\n        cleanup()\n      }\n    }\n\n    timerId = setTimeout(onTimeout, self._http2SessionIdleTime)\n  }\n\n  var sessionInterface = {\n    session: http2\n      .connect(origin)\n      .once('error', cleanup)\n      .once('goaway', cleanup),\n\n    onRequestStart: function onRequestStart() {\n      ++ongoingRequests\n      clearInactivityTimeout()\n    },\n\n    onRequestEnd: function onRequestEnd() {\n      --ongoingRequests\n\n      // Set inactivity timer only if there are no ongoing requests.\n      if (ongoingRequests === 0) {\n        setInactivityTimeout()\n      }\n    },\n  }\n\n  this._sessionMap[sessionKey] = sessionInterface\n\n  return sessionInterface\n}\n\n/**\n * Performs cleanup for broken session.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request.\n * @returns {void}\n */\nHttp2Adapter.prototype._cleanupSessionFor = function(origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin\n\n  if (this._sessionMap[sessionKey]) {\n    this._sessionMap[sessionKey].session.close()\n    delete this._sessionMap[sessionKey]\n  }\n}\n\n/**\n * Issues http requests using http2 module.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\nHttp2Adapter.prototype.execute = function(options) {\n  var self = this\n  var isStreaming = options.streamConsumer != null\n\n  return new Promise(function(resolvePromise, rejectPromise) {\n    var isPromiseSettled = false\n    var isCanceled = false\n\n    var resolve = function(value) {\n      isPromiseSettled = true\n      resolvePromise(value)\n    }\n\n    // If an error has occurred after the Promise is settled\n    // we need to call streamConsumer.onError instead of reject function.\n    // Possible scenario is aborting request when stream is already being consumed.\n    var rejectOrOnError = function(error) {\n      if (isPromiseSettled && isStreaming) {\n        return options.streamConsumer.onError(error)\n      }\n\n      isPromiseSettled = true\n      rejectPromise(error)\n    }\n\n    var onSettled = function() {\n      sessionInterface.onRequestEnd()\n\n      if (options.signal) {\n        options.signal.removeEventListener('abort', onAbort)\n      }\n    }\n\n    var onError = function(error) {\n      onSettled()\n      rejectOrOnError(error)\n    }\n\n    var onAbort = function() {\n      isCanceled = true\n      onSettled()\n      request.close(http2.constants.NGHTTP2_CANCEL)\n      rejectOrOnError(new errors.AbortError())\n    }\n\n    var onTimeout = function() {\n      isCanceled = true\n      onSettled()\n      request.close(http2.constants.NGHTTP2_CANCEL)\n      rejectOrOnError(new errors.TimeoutError())\n    }\n\n    var onResponse = function(responseHeaders) {\n      var status = responseHeaders[http2.constants.HTTP2_HEADER_STATUS]\n      var isOkStatus = status >= 200 && status < 400\n      var processStream = isOkStatus && isStreaming\n      var responseBody = ''\n\n      var onData = function(chunk) {\n        if (processStream) {\n          return options.streamConsumer.onData(chunk)\n        }\n\n        responseBody += chunk\n      }\n\n      var onEnd = function() {\n        if (!isCanceled) {\n          onSettled()\n        }\n\n        if (!processStream) {\n          return resolve({\n            body: responseBody,\n            headers: responseHeaders,\n            status: status,\n          })\n        }\n\n        // Call .onError with TypeError only if the request hasn't been canceled\n        // in order to align on how FetchAdapter works - it throws the TypeError\n        // due to underlying fetch API mechanics.\n        if (!isCanceled) {\n          options.streamConsumer.onError(new TypeError('network error'))\n        }\n      }\n\n      if (processStream) {\n        resolve({\n          // Syntactic stream representation.\n          body: '[stream]',\n          headers: responseHeaders,\n          status: status,\n        })\n      }\n\n      request.on('data', onData).on('end', onEnd)\n    }\n\n    try {\n      var pathname =\n        (options.path[0] === '/' ? options.path : '/' + options.path) +\n        util.querystringify(options.query, '?')\n      var requestHeaders = Object.assign({}, options.headers, {\n        [http2.constants.HTTP2_HEADER_PATH]: pathname,\n        [http2.constants.HTTP2_HEADER_METHOD]: options.method,\n      })\n      var sessionInterface = self._resolveSessionFor(\n        options.origin,\n        isStreaming\n      )\n      var request = sessionInterface.session\n        .request(requestHeaders)\n        .setEncoding('utf8')\n        .on('error', onError)\n        .on('response', onResponse)\n\n      sessionInterface.onRequestStart()\n\n      // Set up timeout only if no signal provided.\n      if (!options.signal && options.timeout) {\n        request.setTimeout(options.timeout, onTimeout)\n      }\n\n      if (options.signal) {\n        options.signal.addEventListener('abort', onAbort)\n      }\n\n      if (options.body != null) {\n        request.write(options.body)\n      }\n\n      request.end()\n    } catch (error) {\n      self._cleanupSessionFor(options.origin, isStreaming)\n      rejectOrOnError(error)\n    }\n  })\n}\n\nmodule.exports = Http2Adapter\n"]},"metadata":{},"sourceType":"script"}